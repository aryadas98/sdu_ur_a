# -*- coding: utf-8 -*-
"""Python Trajectory Generator (with Negative Positions)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w5SkIudp9vmnPwrb0Wcc_ySvNVO6EJDk
"""

import numpy as np
import math
from scipy.integrate import cumulative_trapezoid
import matplotlib.pyplot as plt

def gen_path_profile(p_start, p_end, t_points, v_max=None, dt=0.3, min_slope=0.25, max_slope=0.3):
    """
    Generate a single trajectory from p_start to p_end.

    Args:
        p_start (float): Starting position.
        p_end (float): Ending position.
        t_points (np.ndarray): 8 time points [t1..t8].
        v_max (float, optional): Max velocity. Defaults to pi.
        dt (float, optional): Sampling timestep. Defaults to 0.3.
        min_slope (float, optional): Minimum slope for solver. Defaults to 0.25.
        max_slope (float, optional): Maximum slope for solver. Defaults to 0.3.

    Returns:
        (time_vec, pos_vec, vel_vec, slopes)
    """
    if len(t_points) != 8 or np.any(np.diff(t_points) < 0) or t_points[0] != 0:
        raise ValueError("t_points must be a 1x8 monotonically increasing vector starting with t1=0.")

    if v_max is None:
        v_max = math.pi

    p_delta = p_end - p_start
    direction = np.sign(p_delta)

    # Trivial case: no motion
    if direction == 0:
        t_total = t_points[-1]
        time_vec = np.arange(0, t_total + dt, dt)
        pos_vec = np.full_like(time_vec, p_start)
        vel_vec = np.zeros_like(time_vec)
        m = np.zeros(7)
        return time_vec, pos_vec, vel_vec, m

    p_delta_abs = abs(p_delta)
    t = t_points
    dt1, dt2, dt3, dt4 = t[1]-t[0], t[2]-t[1], t[3]-t[2], t[4]-t[3]
    t_total = t[-1] - t[0]

    # Random slope search
    valid_slopes_found = False
    max_iterations = 5000
    iter_count = 0
    m12, m34 = 0, 0

    while not valid_slopes_found:
        m12 = min_slope + (max_slope - min_slope) * np.random.rand()
        area_from_m12 = m12 * dt1 * (t_total - dt1)
        m34_coeff = dt3 * (dt3 + dt4)

        if m34_coeff > 1e-9:
            m34 = (p_delta_abs - area_from_m12) / m34_coeff
        else:
            m34 = -1

        v_peak = m12 * dt1 + m34 * dt3
        if 0.5 <= m34 <= 3 and 0 < v_peak <= v_max:
            valid_slopes_found = True

        iter_count += 1
        if iter_count > max_iterations:
            raise RuntimeError("Could not find valid slopes")

    # Slopes + velocity key points
    m_positive = np.array([m12, 0, m34, 0, -m34, 0, -m12])
    v_points = np.zeros(8)
    v_points[1] = m12 * dt1
    v_points[2] = v_points[1]
    v_points[3] = v_points[2] + m34 * dt3
    v_points[4] = v_points[3]
    v_points[5] = v_points[4] - m34 * dt3
    v_points[6] = v_points[5]

    # Continuous arrays
    time_vec = np.arange(0, t_total + dt, dt)
    vel_vec_positive = np.zeros_like(time_vec)

    indices = [(time_vec >= t[i]) & (time_vec < t[i+1]) for i in range(7)]
    indices[-1] = (time_vec >= t[6]) & (time_vec <= t[7])

    vel_vec_positive[indices[0]] = v_points[0] + m_positive[0] * (time_vec[indices[0]] - t[0])
    vel_vec_positive[indices[1]] = v_points[1]
    vel_vec_positive[indices[2]] = v_points[2] + m_positive[2] * (time_vec[indices[2]] - t[2])
    vel_vec_positive[indices[3]] = v_points[3]
    vel_vec_positive[indices[4]] = v_points[4] + m_positive[4] * (time_vec[indices[4]] - t[4])
    vel_vec_positive[indices[5]] = v_points[5]
    vel_vec_positive[indices[6]] = v_points[6] + m_positive[6] * (time_vec[indices[6]] - t[6])

    m = direction * m_positive
    vel_vec = direction * vel_vec_positive

    pos_displacement = cumulative_trapezoid(vel_vec, x=time_vec, initial=0)
    pos_vec = p_start + pos_displacement

    return time_vec, pos_vec, vel_vec, m

def ml_generated_traj(slopes, key_times, dt=0.01):
    """
    Generates a trajectory from a given set of slopes and key time points.
    This is used to reconstruct a trajectory from ML-optimized parameters.
    """
    m12, m34 = slopes[0], slopes[2]
    dt1, dt3 = key_times[1] - key_times[0], key_times[3] - key_times[2]
    t_total = key_times[-1]
    p_start = 0

    v_points = np.zeros(8)
    v_points[1] = m12 * dt1
    v_points[2] = v_points[1]
    v_points[3] = v_points[2] + m34 * dt3
    v_points[4] = v_points[3]
    v_points[5] = v_points[4] - m34 * dt3
    v_points[6] = v_points[5]

    time_vec = np.arange(0, t_total + dt, dt)
    vel_vec = np.zeros_like(time_vec)

    indices = [(time_vec >= key_times[i]) & (time_vec < key_times[i+1]) for i in range(7)]
    indices[-1] = (time_vec >= key_times[6]) & (time_vec <= key_times[7])

    vel_vec[indices[0]] = v_points[0] + slopes[0] * (time_vec[indices[0]] - key_times[0])
    vel_vec[indices[1]] = v_points[1]
    vel_vec[indices[2]] = v_points[2] + slopes[2] * (time_vec[indices[2]] - key_times[2])
    vel_vec[indices[3]] = v_points[3]
    vel_vec[indices[4]] = v_points[4] + slopes[4] * (time_vec[indices[4]] - key_times[4])
    vel_vec[indices[5]] = v_points[5]
    vel_vec[indices[6]] = v_points[6] + slopes[6] * (time_vec[indices[6]] - key_times[6])

    pos_vec = p_start + cumulative_trapezoid(vel_vec, x=time_vec, initial=0)

    return time_vec, pos_vec, vel_vec

def generate_robot_trajectories(
    start_positions=None,
    end_positions=None,
    max_vel=math.pi,
    duration=3.0,
    dt=0.3,
    min_slope=0.25,
    max_slope=3,
):
    """
    Generate trajectories for all joints.
    Returns:
        time (np.ndarray): (N,)
        pos_list (List[np.ndarray]): each (N,)
        vel_list (List[np.ndarray]): each (N,)
        slopes (np.ndarray): (n_joints, 7)
        t_points (np.ndarray): (8,)
        dt_tuple (tuple): (dt1, dt2, dt3, dt4)
    """
    if start_positions is None:
        start_positions = np.array([ math.pi/2, -3*math.pi/4, 0, -math.pi/2, 0, 0 ])
    if end_positions is None:
        end_positions = np.array([ 0, -math.pi/4, math.pi/4, 0, math.pi/4, math.pi/2 ])

    # Time profile
    t1, dt1, dt2, dt3 = 0.0, 0.4, 0.3, 0.45
    dt4 = duration - (dt1 + dt2 + dt3) * 2
    if dt4 <= 0:
        raise ValueError("Duration too short for ramp times")

    t2=t1+dt1; t3=t2+dt2; t4=t3+dt3; t5=t4+dt4
    t6=t5+dt3; t7=t6+dt2; t8=t7+dt1
    input_t_points = np.array([t1, t2, t3, t4, t5, t6, t7, t8], dtype=float)

    # Generate per joint -> lists of 1D arrays
    pos_list, vel_list = [], []
    slopes = np.zeros((len(start_positions), 7))
    time = None

    for j in range(len(start_positions)):
        t_j, pos_j, vel_j, slope_j = gen_path_profile(
            start_positions[j], end_positions[j], input_t_points,
            v_max=max_vel, dt=dt, min_slope=min_slope, max_slope=max_slope
        )
        if time is None:
            time = t_j  # shared time vector
        pos_list.append(pos_j)
        vel_list.append(vel_j)
        slopes[j, :] = slope_j

    return time, pos_list, vel_list, slopes, input_t_points, (dt1, dt2, dt3, dt4)

def save_robot_csvs(
    time,
    pos_list,
    vel_list,
    slopes_matrix,
    dt_tuple,
    traj_filename="robot_traj_input.csv",
    ml_filename="ml_input.csv",
):
    positions_matrix  = np.column_stack(pos_list)  # (N, n_joints)
    velocities_matrix = np.column_stack(vel_list)  # (N, n_joints)
    n_joints = positions_matrix.shape[1]

    # time | pos_* | vel_*
    robot_traj_input = np.hstack((time.reshape(-1, 1), positions_matrix, velocities_matrix))
    header_cols = (
        ["time"]
        + [f"pos_{i+1}" for i in range(n_joints)]
        + [f"vel_{i+1}" for i in range(n_joints)]
    )
    np.savetxt(
        traj_filename,
        robot_traj_input,
        delimiter=",",
        header=",".join(header_cols),
        comments="",
        fmt="%.16g",
    )

    # ML CSV: m12 & m34 per joint + dtâ€™s
    dt1, dt2, dt3, dt4 = dt_tuple
    ml_input = np.concatenate((slopes_matrix[:, 0], slopes_matrix[:, 2], [dt1, dt2, dt3, dt4]))
    ml_header = (
        [f"m12_joint_{i+1}" for i in range(n_joints)]
        + [f"m34_joint_{i+1}" for i in range(n_joints)]
        + ["dt1", "dt2", "dt3", "dt4"]
    )
    np.savetxt(
        ml_filename,
        ml_input.reshape(1, -1),
        delimiter=",",
        header=",".join(ml_header),
        comments="",
        fmt="%.16g",
    )


if __name__ == "__main__":
    # 1) Generate (returns 1D time, and lists of 1D pos/vel)
    time, pos_list, vel_list, slopes, t_points, dt_tuple = generate_robot_trajectories(
        dt=0.15, min_slope=0.25, max_slope=0.3
    )

    # 2) Save CSVs
    save_robot_csvs(time, pos_list, vel_list, slopes, dt_tuple)

    # (Optional) Plot using stacked matrices)
    positions  = np.column_stack(pos_list)
    velocities = np.column_stack(vel_list)

    fig1, axs1 = plt.subplots(2, 1, figsize=(10, 8), sharex=True)
    axs1[0].plot(time, positions, linewidth=2)
    axs1[0].set_title('Original Position vs. Time')
    axs1[0].set_ylabel('Position (rad)')
    axs1[0].grid(True)
    axs1[0].legend([f'Joint {i+1}' for i in range(positions.shape[1])])

    axs1[1].plot(time, velocities, linewidth=2)
    axs1[1].set_title('Original Velocity vs. Time')
    axs1[1].set_xlabel('Time (s)')
    axs1[1].set_ylabel('Velocity (rad/s)')
    axs1[1].grid(True)
    axs1[1].legend([f'Joint {i+1}' for i in range(velocities.shape[1])])

    plt.tight_layout()
    plt.show()
