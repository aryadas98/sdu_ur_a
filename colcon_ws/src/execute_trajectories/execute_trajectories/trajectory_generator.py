# -*- coding: utf-8 -*-
"""Trajectory Generator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11Rs7G1vlLLHDm1chExp180US70SLuauw
"""

import numpy as np
import math
import warnings
from scipy.integrate import cumulative_trapezoid
import matplotlib.pyplot as plt

def gen_trajectory_820(p_start, p_end, t_points, v_max=None):
    """
    This function calculates the required slopes (m12, m34) for a
    user-defined set of 8 time points [t1...t8] to achieve the desired
    displacement from p_start to p_end.

    Args:
        p_start (float): The starting position.
        p_end (float): The ending position.
        t_points (np.ndarray): 1x8 array of time points [t1...t8] where velocity
                               slope changes. Must be monotonically increasing and start at 0.
        v_max (float, optional): The maximum allowed velocity. Defaults to pi.

    Returns:
        tuple: A tuple containing:
            - time_vec (np.ndarray): Column vector of time steps [s].
            - pos_vec (np.ndarray): Column vector of position at each time step.
            - vel_vec (np.ndarray): Column vector of velocity at each time step.
            - m (np.ndarray): 1x7 array of the solved slopes [m12, m23, m34, ...].
    """
    # 1. Input Validation and Parameter Calculation
    if p_end <= p_start:
        raise ValueError("End position (p_end) must be greater than start position (p_start).")
    if len(t_points) != 8 or np.any(np.diff(t_points) < 0) or t_points[0] != 0:
        raise ValueError("t_points must be a 1x8 monotonically increasing vector starting with t1=0.")

    # Set default v_max if not provided
    if v_max is None:
        v_max = math.pi

    p_delta = p_end - p_start  # Total displacement
    dt = 0.01  # Using a smaller dt for smoother curves in Python

    # Time durations
    t = t_points
    dt1 = t[1] - t[0]
    dt2 = t[2] - t[1]
    dt3 = t[3] - t[2]
    dt4 = t[4] - t[3]
    t_total = t[7] - t[0]

    # Verify that the provided time points are symmetrical
    if abs((t[7]-t[6]) - dt1) > 1e-9 or abs((t[6]-t[5]) - dt2) > 1e-9 or abs((t[5]-t[4]) - dt3) > 1e-9:
        warnings.warn("Provided t_points vector does not reflect perfect symmetry.")

    # 2. Find Valid Slopes
    valid_slopes_found = False
    max_iterations = 5000
    iter_count = 0
    m12, m34 = 0, 0 # Initialize here

    while not valid_slopes_found:
        # Randomly choose the first slope in its valid range
        m12 = 0.25 + (2 - 0.25) * np.random.rand()

        # Solve for the unknown slope (m34) using the area formula
        area_from_m12 = m12 * dt1 * (t_total - dt1)
        m34_coeff = dt3 * (dt3 + dt4)

        if m34_coeff > 1e-9:
            m34 = (p_delta - area_from_m12) / m34_coeff
        else:
            m34 = -1  # Invalid solution

        # Validate if the calculated m34 and peak velocity are acceptable
        v_peak = m12 * dt1 + m34 * dt3

        if 0.5 <= m34 <= 3 and 0 < v_peak <= v_max:
            valid_slopes_found = True

        iter_count += 1
        if iter_count > max_iterations:
            print("\n--- DIAGNOSTICS: FAILED TO FIND SOLUTION ---")
            print("Your inputs require a trajectory that violates the constraints.")
            print(f"On the last attempt with m12 = {m12:.2f}:")
            print(f"  - Calculated m34 = {m34:.2f} (Valid range is [0.5, 3.0])")
            print(f"  - Calculated v_peak = {v_peak:.2f} (v_max is {v_max:.2f})")
            print("Recommendation: Adjust your inputs (time, distance, or v_max).")
            raise RuntimeError(f"Could not find valid slopes within {max_iterations} iterations.")

    # 3. Define Final Trajectory Key Points
    m = np.array([m12, 0, m34, 0, -m34, 0, -m12])

    v_points = np.zeros(8)
    v_points[1] = m12 * dt1
    v_points[2] = v_points[1]
    v_points[3] = v_points[2] + m34 * dt3
    v_points[4] = v_points[3]
    v_points[5] = v_points[4] - m34 * dt3
    v_points[6] = v_points[5]

    # 4. Generate Continuous Trajectory Arrays
    time_vec = np.arange(0, t_total + dt, dt)
    vel_vec = np.zeros_like(time_vec)

    # Define boolean indices for each segment
    idx1 = (time_vec >= t[0]) & (time_vec < t[1])
    idx2 = (time_vec >= t[1]) & (time_vec < t[2])
    idx3 = (time_vec >= t[2]) & (time_vec < t[3])
    idx4 = (time_vec >= t[3]) & (time_vec < t[4])
    idx5 = (time_vec >= t[4]) & (time_vec < t[5])
    idx6 = (time_vec >= t[5]) & (time_vec < t[6])
    idx7 = (time_vec >= t[6]) & (time_vec <= t[7])

    # Calculate velocity for each segment
    vel_vec[idx1] = v_points[0] + m[0] * (time_vec[idx1] - t[0])
    vel_vec[idx2] = v_points[1]
    vel_vec[idx3] = v_points[2] + m[2] * (time_vec[idx3] - t[2])
    vel_vec[idx4] = v_points[3]
    vel_vec[idx5] = v_points[4] + m[4] * (time_vec[idx5] - t[4])
    vel_vec[idx6] = v_points[5]
    vel_vec[idx7] = v_points[6] + m[6] * (time_vec[idx7] - t[6])

    # Calculate position by integrating velocity
    # cumulative_trapezoid needs an initial value to match MATLAB's output size
    pos_vec = p_start + cumulative_trapezoid(vel_vec, x=time_vec, initial=0)

    return time_vec, pos_vec, vel_vec, m

# ==============================================================================
# Main script section that calls the function
# ==============================================================================
if __name__ == "__main__":
    # Define TRAJECTORY PARAMETERS
    start_positions = np.zeros(6)
    end_positions = np.array([math.pi/2, math.pi/2, math.pi/2, math.pi/4, math.pi/4, math.pi/4])
    max_vel = math.pi
    duration = 3.0

    # Define TIME PROFILE
    t1 = 0
    dt1 = 0.4   # Duration of first ramp
    dt2 = 0.3   # Duration of first flat section
    dt3 = 0.45  # Duration of second ramp
    dt4 = duration - (dt1 + dt2 + dt3) * 2  # Duration of center flat segment

    if dt4 <= 0:
        print("Error: The total duration is too short for the ramp times. Exiting.")
    else:
        t2 = t1 + dt1
        t3 = t2 + dt2
        t4 = t3 + dt3
        t5 = t4 + dt4
        t6 = t5 + dt3  # Symmetrical
        t7 = t6 + dt2  # Symmetrical
        t8 = t7 + dt1  # Symmetrical
        input_t_points = np.array([t1, t2, t3, t4, t5, t6, t7, t8])

        # Pre-allocate arrays to store results
        # We need to run one trajectory first to know the output size
        time, temp_pos, _, _ = gen_trajectory_820(start_positions[0], end_positions[0], input_t_points, max_vel)
        num_steps = len(time)
        positions = np.zeros((num_steps, 6))
        velocities = np.zeros((num_steps, 6))
        slopes = np.zeros((6, 7))

        # Put the first result in
        positions[:, 0] = temp_pos

        # Loop through the remaining trajectories
        for i in range(1, 6):
            _, pos, vel, slope = gen_trajectory_820(start_positions[i], end_positions[i], input_t_points, max_vel)
            positions[:, i] = pos
            velocities[:, i] = vel
            slopes[i, :] = slope

        # Get the results for the first trajectory again to fill velocities and slopes
        _, _, vel1, slope1 = gen_trajectory_820(start_positions[0], end_positions[0], input_t_points, max_vel)
        velocities[:, 0] = vel1
        slopes[0, :] = slope1

        # Save as csv
        robot_traj_input = np.hstack((time.reshape(-1, 1), positions, velocities))
        ml_input = np.concatenate((slopes[:, 0], slopes[:, 2], [dt1, dt2, dt3, dt4]))
        # Save the trajectory data
        np.savetxt("robot_traj_input.csv", robot_traj_input, delimiter=",")

        # Save the machine learning input data as a single row
        np.savetxt("ml_input.csv", ml_input.reshape(1, -1), delimiter=",")


        # PRINT END POSITIONS, PEAK VELOCITY, AND SLOPES
        print("End Positions for Each Joint:")
        print(end_positions)
        print("\nSlopes for Each Joint (row):")
        print(slopes)
        max_velocities = np.max(velocities, axis=0)
        print(f"\nMaximum Velocities for Each Joint (<{max_vel:.2f}):")
        print(max_velocities)

        # Create subplots for position and velocity
        fig, axs = plt.subplots(2, 1, figsize=(10, 8), sharex=True)

        # Position subplot
        axs[0].plot(time, positions, linewidth=2)
        axs[0].set_title('Position of Joints vs. Time')
        axs[0].set_ylabel('Position (rad)')
        axs[0].grid(True)
        axs[0].legend([f'Joint {i+1}' for i in range(6)])

        # Velocity subplot
        axs[1].plot(time, velocities, linewidth=2)
        axs[1].set_title('Velocity of Joints vs. Time')
        axs[1].set_xlabel('Time (s)')
        axs[1].set_ylabel('Velocity (rad/s)')
        axs[1].grid(True)
        axs[1].legend([f'Joint {i+1}' for i in range(6)])

        plt.tight_layout()
        plt.show()